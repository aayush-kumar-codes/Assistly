# assistify-ui

## useAuthRedirect.ts

### Summary

This code defines a custom React hook named `useAuthRedirect`. It uses `next-auth` to check the user's authentication status. If the user is authenticated, it redirects them to a specified path (`redirectTo`). If the user is not authenticated or the status is unknown, it redirects them to the login page (`/login`). The hook utilizes `useRouter` from Next.js for navigation and `useEffect` to trigger the redirection based on the authentication status.

```ts
import { useSession } from "next-auth/react";
import { useRouter } from "next/router";
import { useEffect } from "react";

const useAuthRedirect = (redirectTo: string) => {
  const { status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === "authenticated") {
      router.push(redirectTo);
    } else if (!status || status === "unauthenticated") {
      router.push("/login");
    }
  }, [status, router, redirectTo]);
};

export default useAuthRedirect;

```
## index.tsx

### Summary

This Next.js component checks the user's authentication status. If authenticated, it redirects to the dashboard; if unauthenticated, it redirects to the login page. While determining the status, it displays a loading message. Additionally, it includes a custom head component (`AssistifyHead`).

```tsx
import AssistifyHead from "@/components/common/AssistifyHead";
import { useSession } from "next-auth/react";
import { useRouter } from "next/router";
import { useEffect } from "react";

export default function Home() {
  const { status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === "authenticated") {
      router.push("/dashboard");
    } else if (status === "unauthenticated") {
      router.push("/login");
    }
  }, [status, router]);

  return (
    <>
      <AssistifyHead />
      <div>Loading...</div>
    </>
  );
}

```
## AssistifyHead.test.tsx

### Summary

The code is a set of tests for the `AssistifyHead` component using "@testing-library/react". It checks if the default title is "Assistify" and if a custom title is rendered correctly when passed as a prop.

```tsx
import { render, waitFor } from "@testing-library/react";
import AssistifyHead from "./AssistifyHead";

describe("AssistifyHead", () => {
  it("renders default title", async () => {
    render(<AssistifyHead />);
    await waitFor(() => {
      expect(document.title).toBe("Assistify");
    });
  });

  it("renders custom title", async () => {
    const customTitle = "Custom Title";
    render(<AssistifyHead title={customTitle} />);
    await waitFor(() => {
      expect(document.title).toBe(customTitle);
    });
  });
});

```
## UserProfile.tsx

### Summary

This code defines a React component called `UserProfile` which displays a user profile card. It uses various imported components and hooks, such as `AssistifyLogo`, `Message`, `Protected`, `useSession` from `next-auth/react`, and `useRouter` from `next/router`. The card contains welcome text, the user's name (from the session), and a sign out button. When the "Sign out" button is clicked, it triggers a sign out and redirects the user to the login page. The profile card is styled using Material-UI components such as `Card`, `CardContent`, `Box`, `Typography`, and `Button`.

```tsx
import { AssistifyLogo } from "@/components/common/AssistifyLogo";
import Message from "@/components/Message";
import Protected from "@/components/Protected";
import { Box, Button, Card, CardContent, Typography } from "@mui/material";
import { signOut, useSession } from "next-auth/react";
import { useRouter } from "next/router";

const UserProfile = () => {
  const { data: session } = useSession();
  const router = useRouter();

  const handleSignOut = async () => {
    await signOut({ redirect: false });
    router.push("/login");
  };

  return (
    <Card
      sx={{
        maxWidth: 800,
        margin: "auto",
        bgcolor: "background.paper",
        borderRadius: 2,
        boxShadow: 3,
        p: 4,
      }}
    >
      <CardContent>
        <Box textAlign="center">
          <AssistifyLogo />
          <Typography variant="h4" component="h2" mt={2} color="text.primary">
            Welcome to Assistify
          </Typography>
          <Typography variant="body2" mt={1} color="text.secondary">
            Your AI Assistant Interaction Hub
          </Typography>
          <Typography variant="h6" mt={2} color="text.primary">
            Welcome, {session?.user?.name}
          </Typography>
          <Button
            onClick={handleSignOut}
            fullWidth
            variant="contained"
            color="primary"
            sx={{ mt: 3 }}
          >
            Sign out
          </Button>
          <Protected />
          <Message />
        </Box>
      </CardContent>
    </Card>
  );
};

export default UserProfile;

```
## StyledCard.test.tsx

### Summary

The code is a test suite for the `StyledCard` component using `@testing-library/react`. It performs three tests:

1. Checks if children render correctly within the `StyledCard`.
2. Verifies that default styles (maxWidth, padding) are applied correctly to the `StyledCard`.
3. Ensures custom styles (background color) are applied correctly when passed via the `sx` prop.

```tsx
import { render, screen } from "@testing-library/react";
import StyledCard from "./StyledCard";

/**
 * Test suite for the StyledCard component
 */
describe("StyledCard", () => {
  it("renders children correctly", () => {
    render(
      <StyledCard>
        <div>Test Child</div>
      </StyledCard>
    );
    expect(screen.getByText("Test Child")).toBeInTheDocument();
  });

  it("applies default styles correctly", () => {
    render(
      <StyledCard>
        <div>Test Child</div>
      </StyledCard>
    );
    const cardElement = screen.getByText("Test Child").closest(".MuiCard-root");
    const styles = getComputedStyle(cardElement!);
    expect(styles.maxWidth).toBe("400px");
    expect(styles.padding).toBe("32px");
  });

  it("applies custom styles correctly", () => {
    render(
      <StyledCard sx={{ bgcolor: "primary.main" }}>
        <div>Test Child</div>
      </StyledCard>
    );
    const cardElement = screen.getByText("Test Child").closest(".MuiCard-root");
    const styles = getComputedStyle(cardElement!);
    expect(styles.backgroundColor).toBe("rgb(25, 118, 210)");
  });
});

```
## login.tsx

### Summary

This code defines a functional React component named `Login`. The component does the following:

1. Imports necessary components and functions from external modules.
2. Uses `useState` to manage the state of a random number.
3. Uses `useEffect` to fetch a random number when the component mounts and updates the state with this number.
4. Renders a login page with:
    - A centered `Box` that takes the full viewport height.
    - A head component (`AssistifyHead`).
    - A styled card with a header.
    - A `Typography` component displaying a fetched random number if available.
    - A button that triggers Google sign-in using the `signIn` function from `next-auth/react`.

Finally, the `Login` component is exported as the default export.

```tsx
import AssistifyHead from "@/components/common/AssistifyHead";
import { GoogleLogo } from "@/components/common/GoogleLogo";
import Header from "@/components/common/Header";
import StyledCard from "@/components/common/StyledCard";
import { Box, Button, Typography } from "@mui/material";
import { signIn } from "next-auth/react";
import { useEffect, useState } from "react";
import { fetchRandomNumber } from "../services/service";

const Login = () => {
  const [randomNumber, setRandomNumber] = useState<string | null>(null);

  useEffect(() => {
    const getRandomNumber = async () => {
      const number = await fetchRandomNumber();
      setRandomNumber(number);
    };
    getRandomNumber();
  }, []);

  return (
    <Box
      display="flex"
      alignItems="center"
      justifyContent="center"
      minHeight="100vh"
      bgcolor="background.default"
    >
      <AssistifyHead />
      <StyledCard>
        <Header
          title="Welcome to Assistify"
          subtitle="Your AI Assistant Interaction Hub"
        />
        {randomNumber !== null && (
          <Typography variant="h6" mt={2} color="text.primary">
            Random Number: {randomNumber}
          </Typography>
        )}
        <Button
          onClick={() => signIn("google", { callbackUrl: "/dashboard" })}
          fullWidth
          variant="contained"
          color="primary"
          startIcon={<GoogleLogo />}
          sx={{ mt: 3 }}
        >
          Sign in with Google
        </Button>
      </StyledCard>
    </Box>
  );
};

export default Login;

```
## dashboard.tsx

### Summary

This code defines a `Dashboard` component for a web application. It includes a series of UI components (`AppBar`, `Drawer`, `DrawerToggle`, `MainContent`) for creating a responsive dashboard layout. The component uses authentication session management (`useSession`) and redirects non-authenticated users to the "/dashboard" route (`useAuthRedirect`). It incorporates state management to handle the opening/closing and expanding/collapsing of the drawer. The `Dashboard` component returns a layout wrapped in a `Box` element with `AssistifyHead` and `CssBaseline` for basic styling and normalization.

```tsx
import AssistifyHead from "@/components/common/AssistifyHead";
import AppBar from "@/components/dashboard/AppBar";
import Drawer from "@/components/dashboard/Drawer";
import DrawerToggle from "@/components/dashboard/DrawerToggle";
import MainContent from "@/components/dashboard/MainContent";
import useAuthRedirect from "@/hooks/useAuthRedirect";
import { Box, CssBaseline } from "@mui/material";
import { useSession } from "next-auth/react";
import { useState } from "react";

const minDrawerWidth = 60;
const maxDrawerWidth = 240;

const Dashboard = () => {
  const { data: session, status } = useSession();
  const [mobileOpen, setMobileOpen] = useState(false);
  const [drawerExpanded, setDrawerExpanded] = useState(false);

  // Use the custom hook to handle authentication redirection
  useAuthRedirect("/dashboard");

  if (status === "loading") {
    return <div>Loading...</div>;
  }

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const handleDrawerExpandToggle = () => {
    setDrawerExpanded(!drawerExpanded);
  };

  const drawerWidth = drawerExpanded ? maxDrawerWidth : minDrawerWidth;

  return (
    <Box sx={{ display: "flex" }}>
      <AssistifyHead />
      <CssBaseline />
      <AppBar handleDrawerToggle={handleDrawerToggle} />
      <Drawer
        mobileOpen={mobileOpen}
        handleDrawerToggle={handleDrawerToggle}
        drawerWidth={drawerWidth}
        drawerExpanded={drawerExpanded}
      />
      <DrawerToggle
        drawerExpanded={drawerExpanded}
        handleDrawerExpandToggle={handleDrawerExpandToggle}
        minDrawerWidth={minDrawerWidth}
        maxDrawerWidth={maxDrawerWidth}
        isMobile={window.innerWidth <= 600}
        mobileOpen={mobileOpen}
      />
      <MainContent drawerWidth={drawerWidth} />
    </Box>
  );
};

export default Dashboard;

```
## Dockerfile

### Summary

This Dockerfile sets up a lightweight Node.js environment using the Alpine Linux image. It copies the application code to the container, installs dependencies with `yarn`, builds the application, exposes port 3000 for the app to be accessible, and starts the application using `yarn start`.

```
FROM node:18-alpine

WORKDIR /app
COPY . /app

RUN yarn install --frozen-lockfile
RUN yarn build

EXPOSE 3000

CMD ["yarn", "start"]

```
## GoogleLogo.tsx

### Summary

This code defines a React functional component named `GoogleLogo`. It returns an SVG that visually represents the Google logo using four path elements to draw different parts of the logo. The SVG has a width and height of 5 units each, a margin to the right of 2 units, and includes an `aria-label` for accessibility.

```tsx
export const GoogleLogo = () => (
  <svg className="w-5 h-5 mr-2" viewBox="0 0 24 24" aria-label="google logo">
    <path
      fill="currentColor"
      d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
    />
    <path
      fill="currentColor"
      d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
    />
    <path
      fill="currentColor"
      d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
    />
    <path
      fill="currentColor"
      d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
    />
  </svg>
);

```
## login.spec.ts

### Summary

This code is a Playwright test script for verifying Google login functionality on a web application. It follows these steps:

1. Imports necessary modules and the login function.
2. Sets up test user credentials from environment variables.
3. Defines a test:
   - Navigates to the login page.
   - Verifies the page title.
   - Clicks the "Sign in with Google" button.
   - Executes the Google login process.
   - Asserts that the welcome message and user email are visible on the redirected dashboard page.
   - Asserts the presence of a specific message on the page.

The test is intended to ensure that logging in via Google works correctly and that user-specific elements are displayed afterward.

```ts
import { expect, test } from "@playwright/test";
import { loginToGoogle } from "./login.steps";

const testUserName = process.env.GOOGLE_TEST_NAME ?? "";
const testUserEmail = process.env.GOOGLE_TEST_EMAIL ?? "";

test("login and view dashboard", async ({ page }) => {
  await page.goto("/login");
  await expect(page).toHaveTitle(/Assistify/);

  // Click the "Sign in with Google" button
  const signInButton = page.locator("text=Sign in with Google");
  await signInButton.click();

  await loginToGoogle(page);

  // Wait for the redirect and assert the welcome message
  const welcomeMessage = `Welcome, ${testUserName}`;
  console.log(`"Welcome message: ${welcomeMessage}`);

  await page.waitForSelector(`text=${welcomeMessage}`);
  const welcomeElement = page.locator(`text=${welcomeMessage}`);
  await expect(welcomeElement).toBeVisible();

  const emailElement = page.locator(`text=/${testUserEmail}/`);
  await expect(emailElement).toBeVisible();

  await page.waitForSelector(`text=/Message:/`);

  const messageResponseElement = page.locator(`text=/Message:/`);
  await expect(messageResponseElement).toBeVisible();

  // await saveStorageState(page);
});

```
## axiosInstance.ts

### Summary

This code creates a customized Axios instance with a base URL from environment variables. It includes an interceptor that attaches an authorization header with a Bearer token (`idToken`) from the current user's session (handled by `next-auth`). If obtaining the session fails, the request error is rejected. The configured Axios instance is then exported for use.

```ts
import axios from "axios";
import { getSession } from "next-auth/react";

const axiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_BASE_URL,
});

axiosInstance.interceptors.request.use(
  async (config) => {
    const session = await getSession();
    if (session?.idToken) {
      config.headers.Authorization = `Bearer ${session.idToken}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

export default axiosInstance;

```
## AppBar.tsx

### Summary

This code defines a custom `AppBar` component using Material-UI and Next.js authentication. The `AppBar` includes:
- A fixed position menu bar.
- A toggle button to open a drawer, which only appears on small screens.
- The title "Assistify".
- The user's name and profile picture if the user is authenticated.

**Key components and functionalities:**
1. Imports necessary Material-UI components and icons.
2. Uses the `useSession` hook from `next-auth` to get session data.
3. Defines an `AppBar` component that takes a `handleDrawerToggle` function prop.
4. Renders an app bar with a menu icon button that calls `handleDrawerToggle` when clicked.
5. Displays the user's name and image if a session exists.

**Custom styles:**
- Sets the app bar's position as fixed and changes its background color.
- Adjusts the display of the menu icon based on screen size.
- Styles user image to be circular and of specific size (40x40px).

```tsx
import MenuIcon from "@mui/icons-material/Menu";
import {
  Box,
  IconButton,
  AppBar as MuiAppBar,
  Toolbar,
  Typography,
} from "@mui/material";
import { useSession } from "next-auth/react";

interface AppBarProps {
  handleDrawerToggle: () => void;
}

const AppBar = ({ handleDrawerToggle }: AppBarProps) => {
  const { data: session } = useSession();

  return (
    <MuiAppBar
      position="fixed"
      sx={{
        zIndex: (theme) => theme.zIndex.drawer + 1,
        backgroundColor: "secondary.main",
      }}
    >
      <Toolbar>
        <IconButton
          color="inherit"
          aria-label="open drawer"
          edge="start"
          onClick={handleDrawerToggle}
          sx={{ mr: 2, display: { sm: "none" } }}
        >
          <MenuIcon />
        </IconButton>
        <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
          Assistify
        </Typography>
        {session && (
          <Box display="flex" alignItems="center">
            <Typography variant="body1" mr={2}>
              {session.user?.name}
            </Typography>
            <img
              src={session.user?.image ?? ""}
              alt="User Icon"
              style={{ borderRadius: "50%", width: 40, height: 40 }}
            />
          </Box>
        )}
      </Toolbar>
    </MuiAppBar>
  );
};

export default AppBar;

```
## storageStateHelper.ts

### Summary

This code defines an asynchronous function, `saveStorageState`, which saves the storage state of a given Playwright page. The function carries out the following steps:

1. Saves the storage state to a JSON file named "storageState.json".
2. Reads the content of this JSON file and converts it to a Base64 string.
3. Writes the Base64 encoded string to a file named "storageState.base64".

```ts
import { Buffer } from "buffer";
import { readFileSync, writeFileSync } from "fs";
import { Page } from "playwright";

/**
 * Saves the storage state of the given Playwright page.
 *
 * This function performs the following steps:
 * 1. Saves the storage state to a JSON file.
 * 2. Reads the JSON file and converts its content to a Base64 string.
 * 3. Writes the Base64 encoded storage state to files.
 *
 * @param {Page} page - The Playwright page whose storage state is to be saved.
 * @returns {Promise<void>} - A promise that resolves when the storage state has been saved.
 */
export const saveStorageState = async (page: Page): Promise<void> => {
  try {
    // Save the storage state to a JSON file
    await page.context().storageState({ path: "storageState.json" });
  } catch (e) {
    console.error("Error saving storage state", e);
  }

  // Read the JSON file and convert its content to a Base64 string
  const storageStateJson = readFileSync("storageState.json", "utf-8");
  const storageStateBase64 = Buffer.from(storageStateJson).toString("base64");

  // Write the Base64 encoded storage state to files
  writeFileSync("storageState.base64", storageStateBase64);
};

```
## Drawer.tsx

### Summary

This code defines a side navigation drawer component using Material-UI in React. It imports necessary icons and components, and defines a `Drawer` functional component with props for toggling visibility and adjusting the width of the drawer.

Key points:
- The drawer contains two items: "Home" with a home icon, and "Settings" with a settings icon.
- Drawer items' text visibility depends on whether `drawerExpanded` is true or false.
- There are two versions of the drawer:
  1. A temporary drawer for mobile view, shown when `mobileOpen` is true.
  2. A permanent drawer for larger screens.
- Both variants share the same content and have customizable styles.

```tsx
import {
  Home as HomeIcon,
  Settings as SettingsIcon,
} from "@mui/icons-material";
import {
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Drawer as MuiDrawer,
  Toolbar,
} from "@mui/material";

interface DrawerProps {
  mobileOpen: boolean;
  handleDrawerToggle: () => void;
  drawerWidth: number;
  drawerExpanded: boolean;
}

const Drawer = ({
  mobileOpen,
  handleDrawerToggle,
  drawerWidth,
  drawerExpanded,
}: DrawerProps) => {
  const drawer = (
    <div>
      <Toolbar />
      <List>
        {["Home", "Settings"].map((text, index) => (
          <ListItem button key={text}>
            <ListItemIcon>
              {index % 2 === 0 ? (
                <HomeIcon color="primary" />
              ) : (
                <SettingsIcon color="primary" />
              )}
            </ListItemIcon>
            <ListItemText
              primary={text}
              sx={{ display: drawerExpanded ? "block" : "none" }}
            />
          </ListItem>
        ))}
      </List>
    </div>
  );

  return (
    <>
      <MuiDrawer
        variant="temporary"
        open={mobileOpen}
        onClose={handleDrawerToggle}
        ModalProps={{
          keepMounted: true,
        }}
        sx={{
          display: { xs: "block", sm: "none" },
          "& .MuiDrawer-paper": {
            boxSizing: "border-box",
            width: drawerWidth,
            backgroundColor: "secondary.main",
            transition: "width 0.3s",
          },
        }}
      >
        {drawer}
      </MuiDrawer>
      <MuiDrawer
        variant="permanent"
        sx={{
          display: { xs: "none", sm: "block" },
          "& .MuiDrawer-paper": {
            boxSizing: "border-box",
            width: drawerWidth,
            backgroundColor: "secondary.main",
            transition: "width 0.3s",
          },
        }}
        open
      >
        {drawer}
      </MuiDrawer>
    </>
  );
};

export default Drawer;

```
## HelloWorld.tsx

### Summary

This React code defines a functional component named `HelloWorld` that returns a `div` containing the text "Hello, World!". The component is then exported for use in other parts of the application.

```tsx
import React from "react";

const HelloWorld: React.FC = () => {
  return <div>Hello, World!</div>;
};

export default HelloWorld;

```
## Protected.tsx

### Summary

This code defines a React functional component called `ProtectedComponent` that fetches and displays protected data if the user is authenticated. It uses the `useEffect` hook to trigger the data fetch when the component mounts and employs the `useState` hook to manage the fetched data state. If the user is not authenticated, it prompts them to log in. If the data is still loading, it shows a loading message. Once the data is fetched, it is displayed as a JSON string.

```tsx
import { useEffect, useState } from "react";
import { useFetchProtectedData } from "../services/service";

const ProtectedComponent = () => {
  const [data, setData] = useState(null);
  const { fetchProtectedData, isAuthenticated } = useFetchProtectedData();

  useEffect(() => {
    const fetchData = async () => {
      if (isAuthenticated) {
        try {
          const result = await fetchProtectedData();
          setData(result);
        } catch (error) {
          console.error("Failed to fetch protected data:", error);
        }
      }
    };
    fetchData();
  }, []);

  if (!isAuthenticated) {
    return <div>Please log in to view this content.</div>;
  }

  if (!data) return <div>Loading...</div>;

  return <div>{JSON.stringify(data)}</div>;
};

export default ProtectedComponent;

```
## HelloWorld.test.tsx

### Summary

The code is a unit test using the React Testing Library. It imports necessary functions and components, renders the `HelloWorld` component, and checks if the text "Hello, World!" is present in the document.

```tsx
import { render, screen } from "@testing-library/react";
import HelloWorld from "./HelloWorld";

test("renders Hello, World!", () => {
  render(<HelloWorld />);
  expect(screen.getByText("Hello, World!")).toBeInTheDocument();
});

```
## tailwind.config.ts

### Summary

This code configures Tailwind CSS for a project, specifying which files to scan for class names and extending the default theme with custom colors (e.g., primary, secondary, background, text, and button colors). The configuration does not include any plugins and is exported as the default configuration object.

```ts
import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: "#007acc",
        secondary: "#1e1e1e",
        background: {
          default: "#252526",
          paper: "#1e1e1e",
        },
        text: {
          primary: "#d4d4d4",
          secondary: "#808080",
        },
        button: {
          primary: "#007acc",
          "primary-hover": "#005a9e",
          "focus-ring": "#007acc",
        },
      },
    },
  },
  plugins: [],
};
export default config;

```
## types.ts

### Summary

The code extends the `next-auth` library by adding an optional `idToken` property to both the `Session` and `JWT` interfaces. This allows `idToken` to be accessible within session and JWT objects in a Next.js authentication setup.

```ts
import NextAuth from "next-auth"
import { JWT } from "next-auth/jwt"

declare module "next-auth" {
  interface Session {
    idToken?: string
  }
}

declare module "next-auth/jwt" {
    interface JWT {
      idToken?: string
    }
  }

```
## StyledCard.tsx

### Summary

This code defines a React functional component called `StyledCard` using TypeScript and Material-UI. The component accepts `children` (content to be displayed inside the card) and optional `sx` (style overrides). It renders a `Card` with predefined styles (maximum width, padding, background color, border radius, and shadow) and applies any additional styles passed through `sx`. It uses `CardContent` to wrap the `children`.

```tsx
import { Card, CardContent, SxProps } from "@mui/material";

interface StyledCardProps {
  children: React.ReactNode;
  sx?: SxProps;
}

const StyledCard: React.FC<StyledCardProps> = ({ children, sx }) => (
  <Card
    sx={{
      maxWidth: 400,
      p: 4,
      bgcolor: "secondary.main",
      borderRadius: 2,
      boxShadow: 3,
      ...sx,
    }}
  >
    <CardContent>{children}</CardContent>
  </Card>
);

export default StyledCard;

```
## login.steps.ts

### Summary

This code defines a function `loginToGoogle` that logs into Google using Playwright. It handles two scenarios: one for CI (Continuous Integration) where credentials are skipped, and another for local environments where it fills in the email and password fields, handles navigation steps, and waits for the "Sign Out" text to confirm a successful login. The function uses environment variables to retrieve the Google test email and password.

```ts
import { Page } from "playwright";

const isCI = !!process.env.CI;

const testUserEmail = process.env.GOOGLE_TEST_EMAIL ?? "";
const testUserPassword = process.env.GOOGLE_TEST_PASSWORD ?? "";

/**
 * Logs into Google using the provided Playwright page instance.
 *
 * @param {Page} page - The Playwright page instance to perform actions on.
 * @returns {Promise<void>} - A promise that resolves when the login process is complete.
 *
 * This function handles the login process for Google. It checks if the environment is CI (Continuous Integration)
 * and performs the login steps accordingly. If not in CI, it waits for the email input, fills it, clicks next,
 * waits for the password input, fills it, clicks next, and finally clicks the continue button if it appears.
 * The function waits for the "Sign Out" text to ensure the login was successful.
 */
export const loginToGoogle = async (page: Page): Promise<void> => {
  if (!isCI) {
    await page.waitForSelector('input[type="email"]');
    await page.fill('input[type="email"]', testUserEmail);
    await page.click("text=Next");
    await page.waitForSelector('input[type="password"]');
    await page.fill('input[type="password"]', testUserPassword);
    await page.click("text=Next");

    const continueSelector = "text=Continue";
    await page.waitForSelector(continueSelector, { timeout: 2500 });
    const continueButton = page.locator(continueSelector);
    await continueButton.click();
  }

  await page.waitForSelector("text=Sign Out");
};

```
## AssistifyLogo.tsx

### Summary

This code defines a React functional component named `AssistifyLogo`. It returns an SVG graphic that includes:

- A large purple circle as the background.
- A white diamond shape in the middle.
- A smaller purple circle in the center of the diamond with a white stroke.
- Four white lines extending outward from the middle to the edges of the large circle. 

The SVG is sized at 16x16 units and is centered horizontally with `mx-auto`. It has an aria-label for accessibility describing it as the "assistify logo".

```tsx
export const AssistifyLogo = () => (
  <svg
    className="w-16 h-16 mx-auto"
    viewBox="0 0 100 100"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    aria-label="assistify logo"
  >
    <circle cx="50" cy="50" r="45" fill="#4F46E5" />
    <path d="M30 50 L50 30 L70 50 L50 70 Z" fill="white" />
    <circle
      cx="50"
      cy="50"
      r="10"
      fill="#4F46E5"
      stroke="white"
      strokeWidth="4"
    />
    <path
      d="M50 20 L50 35 M50 65 L50 80 M20 50 L35 50 M65 50 L80 50"
      stroke="white"
      strokeWidth="4"
      strokeLinecap="round"
    />
  </svg>
);

```
## Header.test.tsx

### Summary

This code defines a test suite for the `Header` component using @testing-library/react. It includes four test cases:
1. Checks if the header correctly renders the provided title.
2. Verifies that a provided subtitle is rendered.
3. Ensures that the subtitle is not rendered when it is not provided.
4. Confirms that the header includes the `AssistifyLogo` component.

```tsx
import { render, screen } from "@testing-library/react";
import Header from "./Header";

describe("Header", () => {
  it("renders the title correctly", () => {
    render(<Header title="Test Title" />);
    expect(screen.getByText("Test Title")).toBeInTheDocument();
  });

  it("renders the subtitle when provided", () => {
    render(<Header title="Test Title" subtitle="Test Subtitle" />);
    expect(screen.getByText("Test Subtitle")).toBeInTheDocument();
  });

  it("does not render the subtitle when not provided", () => {
    render(<Header title="Test Title" />);
    expect(screen.queryByText("Test Subtitle")).not.toBeInTheDocument();
  });

  it("renders the AssistifyLogo component", () => {
    render(<Header title="Test Title" />);
    expect(screen.getByLabelText(/assistify logo/i)).toBeInTheDocument();
  });
});

```
## [...nextauth].ts

### Summary

This code sets up authentication using NextAuth with Google as the provider. It configures the Google provider using environment variables for the client ID and secret. The `secret` for NextAuth is also sourced from an environment variable. The code includes callback functions to control redirects, modify JWTs, and customize session data. Specifically, it logs JWT and session events for debugging and attaches Google's ID token to the session and JWT.

```ts
import NextAuth from "next-auth";
import GoogleProvider from "next-auth/providers/google";


export default NextAuth({
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID ?? "",
      clientSecret: process.env.GOOGLE_CLIENT_SECRET ?? "",
    }),
  ],
  secret: process.env.NEXTAUTH_SECRET,
  callbacks: {
    async redirect({ url, baseUrl }) {
      return url.startsWith(baseUrl) ? url : baseUrl;
    },
    async jwt({ token, account }) {
      console.log("JWT callback", token, account);
      if (account?.id_token) {
        token.idToken = account.id_token;
      }
      return token;
    },
    async session({ session, token }) {
      console.log("Session callback", session, token);
      session.idToken = token.idToken;
      return session;
    },
  },
});

```
## jest.setup.ts

### Summary

This code imports custom Jest matchers from the `@testing-library/jest-dom` library, which are used to extend Jest's default assertions for better testing of DOM nodes in React applications.

```ts
import '@testing-library/jest-dom';

```
## MainContent.tsx

### Summary

This code defines a React functional component called `MainContent`, which takes `drawerWidth` as a prop. The component uses Material-UI's `Box` and `Toolbar` components to structure its layout. The main content area adjusts its width based on the `drawerWidth` prop and includes a `UserProfile` component. The `MainContent` component is then exported for use in other parts of the application.

```tsx
import UserProfile from "@/components/dashboard/UserProfile";
import { Box, Toolbar } from "@mui/material";

interface MainContentProps {
  drawerWidth: number;
}

const MainContent = ({ drawerWidth }: MainContentProps) => {
  return (
    <Box
      component="main"
      sx={{
        flexGrow: 1,
        p: 3,
        width: { sm: `calc(100% - ${drawerWidth}px)` },
      }}
    >
      <Toolbar />
      <UserProfile />
    </Box>
  );
};

export default MainContent;

```
## AssistifyHead.tsx

### Summary

This code defines a React component named `AssistifyHead` using Next.js. It sets the document's title to the `title` prop (defaulting to "Assistify") and includes a favicon link. The `useEffect` hook updates the document's title whenever the `title` prop changes. The component uses the `Head` component from Next.js to handle changes in the document's head section.

```tsx
import Head from "next/head";
import { useEffect } from "react";

const AssistifyHead = ({ title = "Assistify" }) => {
  useEffect(() => {
    document.title = title;
  }, [title]);

  return (
    <Head>
      <title>{title}</title>
      <link rel="icon" href="/favicon.png" />
    </Head>
  );
};

export default AssistifyHead;

```
## Header.tsx

### Summary

This React functional component, `Header`, displays a header section with a centered `AssistifyLogo`, a title, and an optional subtitle. It uses Material-UI components for styling and layout. The `Header` component takes `title` and `subtitle` as props, and if the `subtitle` is provided, it is rendered below the title.

```tsx
import { AssistifyLogo } from "@/components/common/AssistifyLogo";
import { Box, Typography } from "@mui/material";

interface HeaderProps {
  title: string;
  subtitle?: string;
}

const Header: React.FC<HeaderProps> = ({ title, subtitle }) => (
  <Box textAlign="center">
    <AssistifyLogo />
    <Typography variant="h4" component="h2" mt={2} color="text.primary">
      {title}
    </Typography>
    {subtitle && (
      <Typography variant="body2" mt={1} color="text.secondary">
        {subtitle}
      </Typography>
    )}
  </Box>
);

export default Header;

```
## Message.tsx

### Summary

This code defines a React functional component called `ProtectedComponent`. It uses a custom hook `usePostMessage` to send a message and check user authentication status. The component retrieves data by sending a message when it is mounted and only proceeds if the user is authenticated. It conditionally renders either a login prompt, a loading message, or the fetched data.

```tsx
import { usePostMessage } from "@/services/service";
import { useEffect, useState } from "react";

const ProtectedComponent = () => {
  const [data, setData] = useState(null);
  const { postMessage, isAuthenticated } = usePostMessage();

  useEffect(() => {
    const fetchData = async () => {
      if (isAuthenticated) {
        try {
          const result = await postMessage("Hello, world!");
          setData(result);
        } catch (error) {
          console.error("Failed to fetch protected data:", error);
        }
      }
    };
    fetchData();
  }, []);

  if (!isAuthenticated) {
    return <div>Please log in to view this content.</div>;
  }

  if (!data) return <div>Loading...</div>;

  return <div>Message: {JSON.stringify(data)}</div>;
};

export default ProtectedComponent;

```
## theme.ts

### Summary

This code creates and exports a custom theme using Material-UI's `createTheme` function. The theme customizes various design aspects, including:

- **Palette**: Defines colors for primary and secondary elements, background, and text.
  - Primary elements are blue with white text.
  - Secondary elements and backgrounds are dark shades.
  - Text colors are light gray for primary and dark gray for secondary.

- **Typography**: Sets the default font family to "Dank Mono, Arial, sans-serif" and customizes font sizes and weights for different text elements (`h1`, `h2`, `body1`, `body2`).

- **Components**: Provides style overrides for specific Material-UI components:
  - `MuiButton`: Customizes appearance, including colors and styles for different states (hover and focus).
  - `MuiCard`: Sets a dark background and light text color.
  - `MuiInputBase`: Specifies background and text colors for input fields.

```ts
import { createTheme } from "@mui/material/styles";

const theme = createTheme({
  palette: {
    primary: {
      main: "#007acc", // Blue color for primary elements
      contrastText: "#ffffff", // White text on primary elements
    },
    secondary: {
      main: "#1e1e1e", // Dark background color
    },
    background: {
      default: "#252526", // Darker background color
      paper: "#1e1e1e", // Slightly lighter background for paper elements
    },
    text: {
      primary: "#d4d4d4", // Light gray text
      secondary: "#808080", // Dark gray text
    },
  },
  typography: {
    fontFamily: "Dank Mono, Arial, sans-serif", // Use Dank Mono for primary text
    h1: {
      fontSize: "2rem",
      fontWeight: 700,
    },
    h2: {
      fontSize: "1.75rem",
      fontWeight: 700,
    },
    body1: {
      fontSize: "1rem",
      fontWeight: 400,
    },
    body2: {
      fontSize: "0.875rem",
      fontWeight: 400,
    },
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          backgroundColor: "#007acc",
          color: "#ffffff",
          "&:hover": {
            backgroundColor: "#005a9e", // Darker blue for hover state
          },
          "&:focus": {
            outline: "none",
            boxShadow: "0 0 0 2px #007acc", // Blue focus ring
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          backgroundColor: "#1e1e1e", // Card background color
          color: "#d4d4d4", // Card text color
        },
      },
    },
    MuiInputBase: {
      styleOverrides: {
        root: {
          backgroundColor: "#252526", // Input background color
          color: "#d4d4d4", // Input text color
        },
      },
    },
  },
});

export default theme;

```
## playwright.config.ts

### Summary

This code configures Playwright for end-to-end (E2E) testing with some additional custom settings:

1. **Dependencies and Configurations**:
   - Imports necessary modules including Playwright, dotenv for environment variables, and plugins for stealth mode.
   - Loads environment variables from `.env` and `.env.local`.

2. **Plugins**:
   - Adds a stealth plugin to Playwright to avoid detection by automated systems.

3. **CI Configuration**:
   - Detects if running in Continuous Integration (CI) environment and sets flags accordingly.

4. **Playwright Test Settings**:
   - Defines configuration for Playwright tests:
     - Tests are located in the `./e2e` directory.
     - Sets test and expectation timeouts.
     - Allows tests to run in parallel.
     - Configures retries and worker numbers based on CI presence.
     - Specifies the base URL for tests, headless mode, screenshot settings, and additional browser launch options.

5. **Projects**:
   - Configures test to run on Chromium using Desktop Chrome settings.

In essence, this script sets up Playwright for robust and stealthy E2E testing, tailored for both local and CI environments.

```ts
import { defineConfig, devices } from "@playwright/test";
import dotenv from "dotenv";
import playwright from "playwright";
import { addExtra } from "playwright-extra";
import StealthPlugin from "puppeteer-extra-plugin-stealth";

dotenv.config();
dotenv.config({ path: ".env.local", override: true });

const extraPlaywright = addExtra(playwright as any);
extraPlaywright.use(StealthPlugin());

const isCI = !!process.env.CI;

export default defineConfig({
  testDir: "./e2e",
  timeout: 60 * 1000,
  expect: {
    timeout: 5000,
  },
  fullyParallel: true,
  forbidOnly: isCI,
  retries: 0,
  workers: isCI ? 1 : undefined,
  reporter: "html",
  use: {
    actionTimeout: 0,
    baseURL: process.env.BASE_URL || "http://localhost:3000",
    trace: "on-first-retry",
    headless: isCI ? true : false,
    screenshot: "only-on-failure",
    launchOptions: {
      args: ["--disable-blink-features=AutomationControlled"],
    },
    storageState: isCI ? "storageState.json" : undefined,
  },
  projects: [
    {
      name: "chromium",
      use: { ...devices["Desktop Chrome"] },
    },
  ],
});

```
## service.ts

### Summary

This code defines utility functions for interacting with a web server using Axios, incorporating authentication status checked through NextAuth's `useSession` hook:

1. **fetchRandomNumber**: A function to fetch a random number from the server and return its message.
2. **useFetchProtectedData**: A custom hook that:
   - Retrieves authentication and session information.
   - Defines a `fetchProtectedData` function to fetch protected data, throwing an error if the user is not authenticated or if the request fails.
3. **usePostMessage**: A custom hook that:
   - Retrieves authentication and session information.
   - Defines a `postMessage` function to post a message to the server, throwing an error if the user is not authenticated or if the request fails.

Both hooks return their respective functions and an `isAuthenticated` boolean based on the user's session status.

```ts
import { AxiosError } from "axios";
import { useSession } from "next-auth/react";
import axiosInstance from "./axiosInstance";

export const fetchRandomNumber = async (): Promise<string> => {
  const response = await axiosInstance.get("/random-number");
  return response.data.message;
};

export const useFetchProtectedData = () => {
  const { data: session, status } = useSession();

  const fetchProtectedData = async (): Promise<any> => {
    if (status !== "authenticated" || !session?.idToken) {
      throw new Error("User is not authenticated");
    }

    try {
      const response = await axiosInstance.get("/protected");
      return response.data;
    } catch (error) {
      if (error) {
        const axiosError = error as AxiosError;
        console.error("Error Response:", axiosError.response?.data);
        throw new Error("Failed to fetch protected data");
      } else {
        throw new Error("An unexpected error occurred");
      }
    }
  };

  return {
    fetchProtectedData,
    isAuthenticated: status === "authenticated",
  };
};

export const usePostMessage = () => {
  const { data: session, status } = useSession();

  const postMessage = async (message: string): Promise<any> => {
    if (status !== "authenticated" || !session?.idToken) {
      throw new Error("User is not authenticated");
    }

    try {
      const response = await axiosInstance.post("/send-message", { message });
      return response.data;
    } catch (error) {
      if (error) {
        const axiosError = error as AxiosError;
        console.error("Error Response:", axiosError.response?.data);
        throw new Error("Failed to send message");
      } else {
        throw new Error("An unexpected error occurred");
      }
    }
  };

  return {
    postMessage,
    isAuthenticated: status === "authenticated",
  };
};

```
## globals.css

### Summary

The code is a Tailwind CSS setup that defines a custom design palette using CSS variables. It includes base, components, and utilities from Tailwind. The `:root` selector specifies color variables for backgrounds, text, and buttons. The `body` element uses these variables to set a dark background and light gray text. Button styles are hinted to be managed externally through a Material-UI theme.

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Design Palette */
:root {
  --bg-primary: #252526; /* Dark background color */
  --bg-secondary: #1e1e1e; /* Slightly lighter background */
  --text-primary: #d4d4d4; /* Light gray text */
  --text-secondary: #808080; /* Dark gray text */
  --btn-primary: #007acc; /* Blue button */
  --btn-primary-hover: #005a9e; /* Darker blue button hover */
  --btn-focus-ring: #007acc; /* Blue focus ring */
}

/* General Styles */
body {
  background-color: var(--bg-primary);
  color: var(--text-primary);
}

/* Button styles are now managed by the MUI theme */

```
## _app.tsx

### Summary

This code defines the main application component `AssistifyApp` for a Next.js application. It wraps the application with several providers:

1. **SessionProvider** from `next-auth` for managing user sessions.
2. **ThemeProvider** from `@mui/material` to apply a custom theme.
3. **CssBaseline** from `@mui/material` to reset and standardize CSS.

It imports global styles and a custom theme, then renders the individual page components with their respective props.

```tsx
import { CssBaseline, ThemeProvider } from "@mui/material";
import { SessionProvider } from "next-auth/react";
import type { AppProps } from "next/app";
import "../styles/globals.css";
import theme from "../styles/theme";

function AssistifyApp({
  Component,
  pageProps: { session, ...pageProps },
}: AppProps) {
  return (
    <SessionProvider session={session}>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <Component {...pageProps} />
      </ThemeProvider>
    </SessionProvider>
  );
}

export default AssistifyApp;

```
## .env.default

### Summary

This code sets up environment variables for a project, including credentials for Google OAuth (client ID and secret), a secret for NextAuth authentication, and URLs for the app and API. It also configures Playwright testing settings with a test user's name, email, and password.

```default
GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}
NEXTAUTH_SECRET=${NEXTAUTH_SECRET}
NEXTAUTH_URL=http://localhost:3000

# Project Settings
NEXT_PUBLIC_API_BASE_URL=http://localhost:8000

# Playwright Settings
GOOGLE_TEST_NAME="Google Test User"
GOOGLE_TEST_EMAIL=your-email@example.com
GOOGLE_TEST_PASSWORD=your-password

```
## jest.config.ts

### Summary

This code sets up a Jest configuration for a Next.js project. It imports necessary modules, creates a Jest config using Next.js specific settings, and defines various configuration options like verbosity, mock clearing, coverage collection, test environment, and paths to ignore during testing. Finally, it exports the customized Jest configuration.

```ts
import type { Config } from 'jest';
import nextJest from 'next/jest.js';
import 'ts-node/register';

const createJestConfig = nextJest({
  dir: './',
})

const config: Config = {
  verbose: true,
  clearMocks: true,
  collectCoverage: true,
  coverageDirectory: "coverage",
  coverageProvider: "v8",
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
  testPathIgnorePatterns: ['<rootDir>/e2e/'],
};

export default createJestConfig(config)

```
## DrawerToggle.tsx

### Summary

This code defines a React functional component called `DrawerToggle` using TypeScript. It imports specific icons and components from the Material-UI library. The component receives several props related to the drawer's state and appearance (e.g., `drawerExpanded`, `handleDrawerExpandToggle`, etc.). When rendered, it displays an `IconButton` that switches between a left and right chevron icon based on the drawer's expansion state. The button's position and animation properties are dynamically adjusted using Material-UI's styling system. If the component is used in a mobile context and the drawer is not open, it returns null and renders nothing.

```tsx
import {
  ChevronLeft as ChevronLeftIcon,
  ChevronRight as ChevronRightIcon,
} from "@mui/icons-material";
import { IconButton } from "@mui/material";

interface DrawerToggleProps {
  drawerExpanded: boolean;
  handleDrawerExpandToggle: () => void;
  minDrawerWidth: number;
  maxDrawerWidth: number;
  isMobile: boolean;
  mobileOpen: boolean;
}

const DrawerToggle = ({
  drawerExpanded,
  handleDrawerExpandToggle,
  minDrawerWidth,
  maxDrawerWidth,
  isMobile,
  mobileOpen,
}: DrawerToggleProps) => {
  if (isMobile && !mobileOpen) {
    return null;
  }

  return (
    <IconButton
      onClick={handleDrawerExpandToggle}
      sx={{
        position: "absolute",
        top: "50%",
        left: drawerExpanded ? maxDrawerWidth - 20 : minDrawerWidth - 20,
        transform: "translateY(-50%)",
        backgroundColor: "secondary.main",
        color: "primary.main",
        transition: "left 0.3s",
        zIndex: 1300, // Ensure the button is above the drawer
      }}
    >
      {drawerExpanded ? <ChevronLeftIcon /> : <ChevronRightIcon />}
    </IconButton>
  );
};

export default DrawerToggle;

```
